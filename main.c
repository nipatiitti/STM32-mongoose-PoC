// SPDX-FileCopyrightText: 2024 Cesanta Software Limited
// SPDX-License-Identifier: GPL-2.0-only or commercial
// Generated by Mongoose Wizard, https://mongoose.ws/wizard/

#include "hal.h"
#include "mongoose/mongoose_config.h"
#include "mongoose/mongoose_glue.h"

static struct speed s_current_speed;

struct mg_timer *g_blink_led1_timer = NULL;
struct mg_timer *g_blink_led2_timer = NULL;
struct mg_timer *g_blink_led3_timer = NULL;

static void blink_led1_timer(void *arg) {
    (void)arg;
    gpio_write(LED1, !gpio_read(LED1));
}

static void blink_led2_timer(void *arg) {
    (void)arg;
    gpio_write(LED2, !gpio_read(LED2));
}

static void blink_led3_timer(void *arg) {
    (void)arg;
    gpio_write(LED3, !gpio_read(LED3));
}

static void update_timers(struct mg_mgr *mgr) {
    (void)mgr;  // Mark parameter as intentionally unused
    struct speed new_speed;
    glue_get_speed(&new_speed);

    // Only update timers if values have changed
    if (memcmp(&new_speed, &s_current_speed, sizeof(struct speed)) != 0) {
        // Store new speed values
        s_current_speed = new_speed;

        // Clear existing timers
        if (g_blink_led1_timer != NULL) {
            mg_timer_free(&mgr->timers, g_blink_led1_timer);
            g_blink_led1_timer = NULL;
        }
        if (g_blink_led2_timer != NULL) {
            mg_timer_free(&mgr->timers, g_blink_led2_timer);
            g_blink_led2_timer = NULL;
        }
        if (g_blink_led3_timer != NULL) {
            mg_timer_free(&mgr->timers, g_blink_led3_timer);
            g_blink_led3_timer = NULL;
        }

        // Add new timers with updated intervals
        if (s_current_speed.led1 > 0) {
            g_blink_led1_timer =
                mg_timer_add(&g_mgr, s_current_speed.led1, MG_TIMER_REPEAT,
                             blink_led1_timer, NULL);
        }
        if (s_current_speed.led2 > 0) {
            g_blink_led2_timer =
                mg_timer_add(&g_mgr, s_current_speed.led2, MG_TIMER_REPEAT,
                             blink_led2_timer, NULL);
        }
        if (s_current_speed.led3 > 0) {
            g_blink_led3_timer =
                mg_timer_add(&g_mgr, s_current_speed.led3, MG_TIMER_REPEAT,
                             blink_led3_timer, NULL);
        }

        MG_INFO(("Updated LED timers: LED1=%dms, LED2=%dms, LED3=%dms",
                 s_current_speed.led1, s_current_speed.led2,
                 s_current_speed.led3));
    }
}

// Check for speed updates every second
static void check_speed_timer(void *arg) {
    (void)arg;
    update_timers(&g_mgr);
}

int main(void) {
    // Cross-platform hardware init
    hal_init();
    MG_INFO(("HAL initialised, starting firmware..."));

    leds_init();

    // This blocks forever. Call it at the end of main(), or in a
    // separate RTOS task. Give that task 8k stack space.
    mongoose_init();

    update_timers(&g_mgr);

    // Add timer to check for speed updates every 10ms
    mg_timer_add(&g_mgr, 10, MG_TIMER_REPEAT, check_speed_timer, NULL);

    MG_INFO(("LED timers initialized: LED1=%dms, LED2=%dms, LED3=%dms",
             s_current_speed.led1, s_current_speed.led2, s_current_speed.led3));

    for (;;) {
        mongoose_poll();
    }

    return 0;
}
